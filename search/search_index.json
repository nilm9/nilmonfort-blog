{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Hey, I'm Nil Monfort <p>I'm an AI Cloud Engineer passionate about building intelligent systems that solve real-world problems. I write about RAG architectures, LLM applications, and the intersection of AI and clean software engineering.</p> <p>Currently working as an AI Engineer at Inditex and sharing insights through my writing.</p>"},{"location":"#latest-writing","title":"Latest writing","text":""},{"location":"#how-i-build-python-projects-my-way-simple-solid","title":"How I Build Python Projects (My Way, Simple &amp; Solid)","text":"<p>An opinionated, scalable way to structure Python projects using hexagonal architecture, SOLID, and practical DDD.</p> <p>If I'll spend more than three days on a project, I shape it with hexagonal architecture. Not the textbook kind, just enough to keep options open. The core idea is simple: business rules in the center, tools at the edges, and small contracts between them.</p> <p>Continue reading \u2192</p> <p>See more on the Writing page.</p>"},{"location":"about/","title":"About","text":"About <p>I'm Nil Monfort, a computer engineer who loves building systems. I started coding in 2020 while studying automotive engineering. Cars didn't click; code did. I switched to computer science and never looked back. Today I work as an AI engineer at Inditex and I also take on freelance projects.</p>"},{"location":"about/#what-i-build","title":"What I build","text":"<p>I turn real problems into working software. Lately that means AI systems: smart assistants (agents), search with context (RAG), and cloud infrastructure. My goal is simple: help medium sized companies ship faster and increase revenue.</p>"},{"location":"about/#a-project-im-proud-of","title":"A project I\u2019m proud of","text":"<p>In 2025 I built an AI platform for a client\u2019s creative team (retail industry). Before, going from idea to print-ready mockups was slow. I built a workflow that turns a short brief into several options, pulls brand colors and logos, saves clean metadata to their CRM, and can run drafts overnight with short notes. Result: much faster cycles (about 5x faster from concept to mockup and 30% fewer revisions).</p>"},{"location":"about/#my-edge","title":"My edge","text":"<p>I span software and applied AI. I moved from early web work into backend and machine learning, which is where I\u2019m happiest. I use clean, simple designs and I can ship end to end in the cloud. I hold the AWS Solutions Architect Associate and I like serverless because it is fast and cost friendly. I also enjoy the business side: talking to users, finding the real need, and tying tech to results.</p>"},{"location":"about/#how-i-work","title":"How I work","text":"<p>I start by clarifying the problem. Then I ship in small, usable slices that work from end to end. Each slice has tests, simple evals for AI parts, and basic logs and checks so we can move fast without breaking things. Keep it simple, easy to maintain, and easy to roll back. I use Cursor for speed and PyCharm when I need to dig into a tricky bug.</p>"},{"location":"about/#my-techie-path","title":"My techie path","text":"<p>I learned the basics in a Python class and switched my major soon after. I worked frontend at a startup and learned AWS, then moved to backend and ML, algorithms, the good stuff. Later I did data engineering, which sharpened my system thinking, but I missed daily coding. Now at Inditex I work on RAG and agent systems, and I still get the same kick from shipping real things.</p>"},{"location":"about/#beyond-code","title":"Beyond code","text":"<p>I\u2019m big on movement: surf when the Mediterranean has waves (not often, haha), gym, calisthenics, and some martial arts. Hard training balances the hard thinking at work and makes me sharper. I care about self improvement and try to be the best version of myself.</p>"},{"location":"about/#work-with-me","title":"Work with me","text":"<p>I help identify where tech can improve your business and turn that into results.</p> <p>Email  nilmonfort98@gmail.com  or find me on LinkedIn (nil-monfort-761660213). </p> <p>We can start with a short call and grow from there.</p>"},{"location":"resume/","title":"Nil Monfort","text":"<p>AI Engineer \u2022 Cloud Architect \u2022 Fitness Enthusiast Barcelona, Catalonia, Spain</p> <p>Contact \ud83d\udce7 nilmonfort98@gmail.com \u00b7 \ud83d\udd17 LinkedIn \u2014 nil-monfort-761660213</p>"},{"location":"resume/#executive-summary","title":"Executive Summary","text":"<p>I\u2019m an AI/ML engineer focused on scalable, end-to-end systems: RAG platforms, agentic microservices, and Cloud Infrastructure. I like clean architecture (hexagonal/ports-and-adapters), strong observability, and fast iteration. I\u2019ve built meta-assistant tooling, LLM validation services, and data workflows that turn traces into actionable insights. Previously I improved fleet-matching algorithms and shipped ML on AWS/Azure; today I apply those skills to LLM-native apps that drive measurable outcomes.</p>"},{"location":"resume/#professional-experience","title":"Professional Experience","text":""},{"location":"resume/#ai-engineer-inditex-knowmad-mood-barcelona-spain","title":"AI Engineer \u2014 Inditex (Knowmad Mood) \u00b7 Barcelona, Spain","text":"<p>Jan 2025 \u2013 Present - End-to-end RAG platform: multi-tenant vectors, hybrid dense+lexical, pluggable LLMs. - Conversational assistants over 60+ unstructured sources; material productivity gains. - AI Truth Guard (FastAPI, hexagonal): precision/recall, tool-selection checks, SSE streaming, PostgreSQL metrics, async runs. - Trace analytics (clustering + sentiment) \u2192 product insights.</p>"},{"location":"resume/#ai-architect-freelancer-contract-barcelona-spain","title":"AI Architect \u2014 Freelancer (Contract) \u00b7 Barcelona, Spain","text":"<p>Jan 2025 \u2013 Present - GenAI design assistant with agentic workflows; designers\u2019 speed 50\u00d7. - Full-stack ideation (React + Python) with multimodal ai, prompt suggestions, classification. - Clean/Hexagonal LLM integration; ML image enhancement (KNN, Lanczos). - Serverless, event-driven AWS deployment with CDK (IaC).</p>"},{"location":"resume/#data-engineer-propelling-tech-barcelona-spain","title":"Data Engineer \u2014 Propelling Tech \u00b7 Barcelona, Spain","text":"<p>Sep 2024 \u2013 Jan 2025 - Medallion Architecture on Databricks (PySpark/Spark SQL); ingestion from SQL Server &amp; Oracle to DLT/BigQuery. - Near-real-time BI (Power BI); automation across GCP Composer/Airflow and Azure Data Factory.</p>"},{"location":"resume/#machine-learning-engineer-avantcab-spain","title":"Machine Learning Engineer \u2014 Avantcab \u00b7 Spain","text":"<p>May 2023 \u2013 Jun 2024 - Sub-second taxi allocation (genetic/greedy/heuristics on AWS Lambda) with caching + pyramid testing. - Two-stage flight delay prediction (classifier + XGBoost regressor).</p>"},{"location":"resume/#full-stack-developer-datoma-spain","title":"Full-Stack Developer \u2014 DATOMA \u00b7 Spain","text":"<p>Jan 2023 \u2013 Sep 2023 - Genomic Marketplace (TypeScript, Vue, PrimeVue) on AWS Amplify with Cognito auth. - Event-driven workflows (SQS + Lambda) and CloudWatch observability.</p>"},{"location":"resume/#freelance-software-developer-spain","title":"Freelance Software Developer \u00b7 Spain","text":"<p>Jan 2021 \u2013 Sep 2023 - \ud835\uddea\ud835\uddf2\ud835\uddef \ud835\uddd4\ud835\uddfd\ud835\uddfd\ud835\uddf9\ud835\uddf6\ud835\uddf0\ud835\uddee\ud835\ude01\ud835\uddf6\ud835\uddfc\ud835\uddfb \ud835\uddd7\ud835\uddf2\ud835\ude03\ud835\uddf2\ud835\uddf9\ud835\uddfc\ud835\uddfd\ud835\uddfa\ud835\uddf2\ud835\uddfb\ud835\ude01: Leveraged the MERN stack (MongoDB, Express, React, Node.js), Google Firestore, JavaScript, HTML, and CSS, alongside WordPress, to build high-performance, aesthetically polished user interfaces and backend services.</p>"},{"location":"resume/#education","title":"Education","text":"<ul> <li>MBA + Master in AI for Business \u2014 ENEB \u00b7 Sep 2024 \u2013 Sep 2025 </li> <li>B.Eng. in Computer Engineering \u2014 Universit\u00e4t Duisburg-Essen \u00b7 Oct 2023 \u2013 Sep 2024 </li> <li>Computer Engineering \u2014 Universitat Rovira i Virgili \u00b7 Aug 2021 \u2013 Jul 2024 </li> <li>Engineering (Automotive Tech) \u2014 UPC Manresa (EPSEM) \u00b7 Sep 2020 \u2013 Jul 2021</li> </ul>"},{"location":"resume/#skills","title":"Skills","text":"<ul> <li>Architecture: Hexagonal / Ports-and-Adapters, DI, SOLID/DRY, event-driven  </li> <li>AI/LLM: RAG, hybrid retrieval, evals &amp; guardrails, agent tooling  </li> <li>Backend: Python (FastAPI), async task queues, SSE, PostgreSQL  </li> <li>Data/ML: Databricks, Delta Lake, MLflow, Scikit-Learn, Keras, clustering, sentiment  </li> <li>Cloud: Azure (Databricks), AWS (S3, Lambda, Batch, SQS, Cognito, IAM), GCP (Run, Functions, Composer)  </li> <li>FE &amp; Viz: Vue, Chart.js, D3.js, Astrato  </li> <li>Ops: Observability, unit/integration testing, CI-ready pipelines</li> </ul>"},{"location":"resume/#certifications","title":"Certifications","text":"<ul> <li>AWS Certified Solutions Architect  </li> <li>Data Engineering with Databricks  </li> <li>Supervised Machine Learning: Regression &amp; Classification  </li> <li>Neural Networks and Deep Learning  </li> <li>Advanced Learning Algorithms</li> </ul>"},{"location":"resume/#languages","title":"Languages","text":"<ul> <li>Spanish \u2014 Native  </li> <li>Catalan \u2014 Native  </li> <li>English \u2014 Professional Working  </li> <li>German \u2014 Professional Working</li> </ul>"},{"location":"resume/#get-in-touch","title":"Get in touch","text":"<p>\ud83d\udce7 Email me \u00b7 \ud83d\udcac Connect on LinkedIn</p> <p>Back to top</p>"},{"location":"writing/","title":"Writing","text":"<p>I write about:</p> <ul> <li> <p>RAG Systems: Building production-ready retrieval-augmented generation systems</p> </li> <li> <p>AI Engineering: Best practices for deploying and maintaining AI applications</p> </li> <li> <p>Software Architecture: Clean code and system design principles</p> </li> <li> <p>Personal Growth: Lessons learned in my journey as an AI engineer</p> </li> </ul> <p>Use the Archive and Categories sections in the sidebar to explore posts by year or topic.</p>"},{"location":"writing/tags/","title":"Tags","text":""},{"location":"writing/tags/#tag:architecture","title":"architecture","text":"<ul> <li>            How I Build Python Projects (My Way, Simple &amp; Solid)          </li> </ul>"},{"location":"writing/tags/#tag:ddd","title":"ddd","text":"<ul> <li>            How I Build Python Projects (My Way, Simple &amp; Solid)          </li> </ul>"},{"location":"writing/tags/#tag:hexagonal-architecture","title":"hexagonal-architecture","text":"<ul> <li>            How I Build Python Projects (My Way, Simple &amp; Solid)          </li> </ul>"},{"location":"writing/tags/#tag:python","title":"python","text":"<ul> <li>            How I Build Python Projects (My Way, Simple &amp; Solid)          </li> </ul>"},{"location":"writing/tags/#tag:solid","title":"solid","text":"<ul> <li>            How I Build Python Projects (My Way, Simple &amp; Solid)          </li> </ul>"},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/","title":"How I Build Python Projects (My Way, Simple &amp; Solid)","text":"<p>An opinionated, scalable way to structure Python projects using hexagonal architecture, SOLID, and practical DDD.</p> <p>A friend asked me: \u201cWhat\u2019s the proper way to build a Python project?\u201d Here\u2019s my take.</p> <p>It\u2019s what I use for clients and at my 9 to 5. I like SOLID and Domain\u2011Driven Design, but I don\u2019t chase perfection. I just want code that stays tidy when the app grows.</p> <p>Python is flexible. That\u2019s great until the codebase gets big and files start calling each other in weird ways. In compiled worlds like Java, the compiler blocks some messes before they spread. In Python, you can ship those messes. So I add a few small rules that make good habits the default.</p> <p>Biggest mistakes I see:</p> <ul> <li>No boundaries: business logic mixed with HTTP, DB, or SDK calls.</li> <li>God modules: one file does everything.</li> <li>Hidden globals: config sprinkled everywhere; hard to test.</li> <li>Dynamic typing without discipline: runtime errors far from the source.</li> </ul>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#my-rule-of-thumb","title":"My rule of thumb","text":"<p>If I\u2019ll spend more than three days on a project, I shape it with hexagonal architecture (my rule of thumb, hahaha). Not the textbook kind,just enough to keep options open. The core idea is simple: business rules in the center, tools at the edges, and small contracts between them.</p> <p></p> <p>Inbound adapters \u2192 Application (use cases) \u2192 Domain (entities, value objects, simple rules). Outbound ports from Application point to adapters in Infrastructure (DB, cache, vector store, LLM, email). Calls flow left to right; dependencies point inward.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#the-three-folders-that-do-most-of-the-work","title":"The three folders that do most of the work","text":"<ul> <li>domain \u2014 the people, things, and rules. Entities and value objects. Ports live here.</li> <li>application \u2014 the actions. Use cases coordinate work using the domain and ports. No tech details.</li> <li>infrastructure \u2014 the details. Adapters for HTTP, DB, queues, vector stores, and LLMs.</li> </ul> <p>Think of it like this: domain = actors and rules. Application = what those actors do. Infrastructure = how it actually happens. Direction matters. An inbound adapter (REST, CLI, queue) calls a use case. The use case uses the domain. When it needs the outside world, it talks to a port that an adapter implements.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#ports-and-adapters-in-plain-words","title":"Ports and adapters in plain words","text":"<p>A port is a promise the core makes: \u201cthis is what I need from the outside.\u201d An adapter is a concrete tool that keeps that promise. Same port, many adapters (Postgres, a vector DB, a fake for tests). The use case does not care which one you plug in.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#a-clear-rag-ingestion-flow-endtoend","title":"A clear RAG ingestion flow (end\u2011to\u2011end)","text":"<p>Think of one REST endpoint: <code>POST /ingest</code>.</p> <p>Step 1 \u2013 Controller (inbound adapter). The API gets a JSON body like <code>{ id, source_type, location, metadata }</code>. The controller validates it and turns it into a simple DTO. Then it calls the IngestDocument use case.</p> <p>Step 2 \u2013 Use case (application). The use case coordinates the work using ports:</p> <ul> <li><code>LoaderPort</code> \u2013 loads raw text from a source (local file, S3, URL).</li> <li><code>SplitterPort</code> \u2013 splits text into chunks.</li> <li><code>EmbedderPort</code> \u2013 turns chunks into vectors.</li> <li><code>DocumentStorePort</code> / <code>VectorStorePort</code> \u2013 saves the document/chunks/vectors.</li> </ul> <p>Step 3 \u2013 Domain (center). We keep a <code>Document</code> entity with <code>id</code>, <code>text</code> (or <code>chunks</code>), and maybe <code>metadata</code>. Simple rules live here (e.g., max chunk size, allowed file types).</p> <p>Step 4 \u2013 Adapters (infrastructure). Each port gets a matching adapter: a filesystem or S3 loader, a specific splitter, an OpenAI or local embedder, a Postgres or vector\u2011DB store. You can swap these per environment without touching the use case.</p> <p>Result. The use case returns something like <code>{ ingested: true, chunk_count: N }</code>. The controller maps that to an HTTP response. Same flow on every deploy; only the adapters change.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#minimal-practical-deps","title":"Minimal, practical deps","text":"<p>I use uv for dependency management because it\u2019s fast. For config and secrets I stick to a <code>.env</code> plus Pydantic Settings. It\u2019s boring and it works.</p> <p>I also use a tiny factory for environments\u2014<code>DEV</code>, <code>STAGE</code>, <code>PROD</code>\u2014controlled by env vars. Flip a flag and the app builds the right adapters: local Postgres vs cloud, OpenAI vs another LLM, in\u2011memory cache vs Redis. At startup I wire everything with a small dependency injector so use cases get ports, not concrete classes.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#a-tiny-slice-of-the-pattern-one-file-conceptual","title":"A tiny slice of the pattern (one file, conceptual)","text":"<p>Here\u2019s a short sketch that shows a port, an adapter, a use case, and simple wiring.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Protocol\n\n# DOMAIN (port)\nclass DocumentStorePort(Protocol):\n    def save(self, doc_id: str, text: str) -&gt; None: ...\n\n# APPLICATION (use case)\n@dataclass\nclass IngestDocument:\n    store: DocumentStorePort\n    def __call__(self, doc_id: str, text: str) -&gt; None:\n        # business rules would live here (validation, splitting, etc.)\n        self.store.save(doc_id, text)\n\n# INFRASTRUCTURE (adapter)\nclass PostgresDocumentStore:\n    def __init__(self, conn):\n        self.conn = conn\n    def save(self, doc_id: str, text: str) -&gt; None:\n        # pretend SQL; in real code use a repo/ORM\n        self.conn.execute(\"INSERT INTO docs(id, body) VALUES (%s, %s)\", (doc_id, text))\n\n# WIRING (bootstrap)\nconn = object()  # replace with real connection\nstore = PostgresDocumentStore(conn)\nuse_case = IngestDocument(store)\nuse_case(\"doc-123\", \"Hello, hexagon.\")\n</code></pre> <p>The use case is blind to Postgres. Swap <code>PostgresDocumentStore</code> for a vector store or a fake for tests and nothing breaks.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#dtos-schemas-and-errors","title":"DTOs, schemas, and errors","text":"<p>Keep DTOs and Pydantic schemas at the edges where data crosses a boundary: HTTP handlers, message consumers, or DB mappers. Convert them to plain domain objects early. Do the reverse on the way out. For errors, define a few domain types (<code>DomainError</code>, <code>NotFound</code>, <code>RuleViolation</code>) and map them to HTTP codes or queue retry logic in the inbound adapters.</p> <p>Tiny mapping example (edge \u2194 domain). A controller receives <code>IngestRequestDTO</code>, maps it to a <code>Document</code> entity, calls the use case, then maps the result back to an <code>IngestResponseDTO</code>.</p> <pre><code># DTOs at the edge\nfrom pydantic import BaseModel\nclass IngestRequestDTO(BaseModel):\n    id: str; source_type: str; location: str; metadata: dict | None = None\nclass IngestResponseDTO(BaseModel):\n    ingested: bool; chunk_count: int\n\n# Domain entity\nclass Document(BaseModel):\n    id: str; text: str; metadata: dict | None = None\n\n# Simple mappers\ndef to_domain(dto: IngestRequestDTO, loader) -&gt; Document:\n    text = loader.load(dto.source_type, dto.location)  # calls a LoaderPort\n    return Document(id=dto.id, text=text, metadata=dto.metadata)\n\n\ndef to_dto(result) -&gt; IngestResponseDTO:\n    return IngestResponseDTO(ingested=result.ok, chunk_count=result.chunks)\n</code></pre> <p>The DTOs are for I/O. The domain stays plain and focused on rules. Mappers keep the boundary clean.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#logging-i-can-live-with","title":"Logging I can live with","text":"<p>Log at the edges, not in every method. Inbound adapters log request IDs, actor IDs, and use case names. Outbound adapters log calls to external systems and durations. Use structured logs so search is easy. Pass the request ID along with context vars.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#the-gold-path-quick-and-clear","title":"The Gold Path, quick and clear","text":"<p>Layers go Inbound \u2192 Application \u2192 Domain \u2192 Outbound. Config lives in <code>.env</code> plus Pydantic Settings. DI wires ports to adapters at startup. Map errors once at the edge. Keep DTOs and schemas at boundaries. Ship default adapters for DB, cache, queue or email if you need them, a vector store, and an LLM client. For ops, expose <code>/health</code> for liveness and <code>/ready</code> for checks like DB ping, cache ping, and LLM token checks.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#folder-sketch-that-scales","title":"Folder sketch that scales","text":"<p>My trees match the screenshot. <code>domain</code> holds <code>model</code> (entities, value objects) and <code>ports</code>. <code>application</code> holds <code>use_cases</code> and sometimes mappers. <code>infrastructure</code> has <code>adapters/input</code> for REST or queues and <code>adapters/output</code> for DB, cache, vector, email, and LLM. A small <code>config</code> area wires settings and DI. Names stay boring on purpose.</p> <p>Here\u2019s a fuller tree you can copy when you want a production\u2011ready layout:</p> <pre><code>code/\n\u251c\u2500 application/                     # Orchestrates use cases; thin coordination layer\n\u2502  \u251c\u2500 mappers/                      # Transforms DTOs \u21c6 domain models\n\u2502  \u2514\u2500 use_cases/                    # Application services (imperative workflows)\n\u2502\n\u251c\u2500 domain/                          # Pure business/core; framework-free\n\u2502  \u251c\u2500 model/\n\u2502  \u2502  \u251c\u2500 dtos/                      # Inbound/outbound data shapes (no behavior)\n\u2502  \u2502  \u251c\u2500 entities/                  # Stateful domain objects with identity\n\u2502  \u2502  \u2514\u2500 value_objects/             # Immutable types (no identity)\n\u2502  \u251c\u2500 ports/                        # Interfaces the core expects/exports\n\u2502  \u2514\u2500 use_cases/                    # Use case definitions (interfaces/contracts)\n\u2502\n\u251c\u2500 infrastructure/                  # Adapters implementing ports; I/O details live here\n\u2502  \u2514\u2500 adapters/\n\u2502     \u251c\u2500 input/                     # Driving adapters (call into the app)\n\u2502     \u2502  \u2514\u2500 rest/                   # HTTP controllers, routing, request parsing\n\u2502     \u2502     \u251c\u2500 mappers/             # REST \u2194 DTO mappers\n\u2502     \u2514\u2500 output/                    # Driven adapters (called by the app)\n\u2502        \u251c\u2500 graph/                  # Langgraph / Pydantic AI\n\u2502        \u251c\u2500 llm/                    # LLM providers/clients (OpenAI, etc.)\n\u2502        \u251c\u2500 mcp/                    # MCP (Model Context Protocol) integrations\n\u2502        \u251c\u2500 memory/                 # Vector store / cache / session memory\n\u2502        \u251c\u2500 data/                            # Persistence layer specifics\n\u2502        \u2502  \u251c\u2500 models/                       # ORM/DB models + DTOs for storage\n\u2502        \u2502  \u2514\u2500 repositories/                 # Repo implementations (DB access)\n\u2502\n\u251c\u2500 config/              # Project-wide configuration      \n\u2502  \u251c\u2500 bootstrap/        # Composition root (Dependency Injector + app start)\n\u2502\n\u2514\u2500 __init__.py (scattered)          # Package markers\n</code></pre>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#what-good-feels-like-day-to-day","title":"What \u201cgood\u201d feels like day to day","text":"<p>I swap providers by changing an env var, not by rewriting a use case. New features start as a new use case, not a new top\u2011level folder. Tests don\u2019t fake the universe; they swap adapters. And my domain files never import Flask, SQLAlchemy, or any vendor SDK.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#when-to-bend-the-rules","title":"When to bend the rules","text":"<p>Don\u2019t build a cathedral for a weekend script. If a project won\u2019t outgrow a single file, let it be a single file. If there\u2019s only one outbound dependency, keep it inline until it hurts. You can extract a port later.</p> <p>The goal is just enough structure to move fast without painting yourself into a corner.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/2025/01/30/how-i-build-python-projects-my-way-simple-and-solid/#takeaway","title":"Takeaway","text":"<p>Use a light hexagonal shape: domain in the center, use cases around it, adapters at the edges. Define ports in the domain, implement them in infrastructure, and wire them at startup. With uv, Pydantic Settings, and a tiny DI container, switching envs and providers becomes a flag flip.</p> <p>That\u2019s it. Simple on purpose. Strong enough for big projects, light enough for fast delivery.</p>","tags":["python","architecture","solid","ddd","hexagonal-architecture"]},{"location":"writing/archive/2025/","title":"2025","text":""},{"location":"writing/category/software-engineering/","title":"Software Engineering","text":""}]}